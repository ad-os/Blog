---
layout: post
title:  "Binary Search Tree"
date:   2015-11-21 14:39:00
categories: jekyll update
---

### What is a binary search tree ?

* The main use of BST is for searching.
* We impose a restriction on the kind of data a node can contain.
* So it reduces the worst case search to O(log base2 n) unlike O(n) in trees.

### Properties of a binary search tree ?

* The nodes on the left of the current node should contain values less than the current node.
* The nodes on the right of the current node should contain values greater than the current node.
* The left and right subtrees must be binary search trees.
* Inorder traversal on BST gives the elements of the tree in the increasing order.Inorder traverses in `left->root->right` manner and as we know the property that root is greater than left and smaller than right so it gives all the elements in increasing order. 

### Binary Search tree declaration

<pre>
struct BinarySearchNode {
	int data;
	struct BinarySearchNode *left;
	struct BinarySearchNode *right;
}</pre>

### Finding a element in a Binary Search Tree

<pre>
struct BinarySearchNode* Find(struct BinarySearchNode *root, int data) {
	if (root->data == NULL) {
		return NULL;
	} else if (root->data > data) {
		return Find(root->left, data);
	} else {
		return Find(root->right, data);
	}
	return root;
}</pre>

### Finding a minimum in a Binary Search Tree

<pre>
struct BinarySearchNode* Min(struct BinarySearchNode *root) {
	if (root == NULL) {
		return NULL;
	} else if (root->left == NULL) {
		return root;
	} else {
		return Min(root->left);
	}
}
</pre>

### Finding a maximum in a Binary Search Tree

<pre>
struct BinarySearchNode* Max(struct BinarySearchNode *root) {
	if (root == NULL) {
		return NULL;
	} else if (root->right == NULL) {
		return root;
	} else {
		return Max(root->left);
	}
}
</pre>

**Time complexity of finding minimum and maximum element will be of the O(n) in worst case `When BST is a skew tree`**

**Inorder Predecessor**
It is the minimum element in the left subtree.

**Inorder Successor**
It is the maximum element in the right subtree.

### Inserting a element in BST

<pre>
struct BinarySearchNode* Insert(struct BinarySearchNode *root, int data) {
	if (root == NULL) {
		//Create a node
		root = (struct BinarySearchNode*)malloc(sizeof(struct BinarySearchNode));
		//Assign data to the node
		root->data = data;
		//Make the left and right child as null
		root->left = NULL;
		root->right = NULL;
	} else {
		if (data < root->data) {
			root->left = Insert(root->left, data);
		} else {
			root->right = Insert(root->right, data);
		}
	}	
	return root;
}
</pre>

**Order of complexity for inserting a element will of the O(n) in worst case `When BST is a skew tree`**

### Deleting a element from a Binary Search Tree

The case can be comprimised of three cases:-

* If the element to be deleted has no child return null to it's parent.
* If the element to be deleted has one child return that child to it's parent.
* If the element to be deleted has two childs then find the maximum element in the left subtree and replace the element to be deleted with the max element found in the left subtree and then recursively delete the element found in the left subtree. 

<pre>
struct BinarySearchNode* Delete(struct BinarySearchNode *root, int data) {
	struct BinarySearchNode* temp;
	if ( root == NULL) {
		printf("Element not found in the tree.\n");
	} else if (data < root->data) {
		root->left = Delete(root->left, data);
	} else if (data > root->data) {
		root->right = Delete(root->right, data);
	} else {
		\\element found
		if (root->right && root->left) {
			temp = Max(root->left);
			root->data = temp->data;
			root->left = Delete(root, temp->data);
		} else {
			\\either one not found or both not found.
			if (root->left == NULL) {
				root = root->right;
			}
			if (root->right == NULL) {
				root = root->left;
			}
		}
	}
	return root;
}
</pre>

**The time complexity for deleting a element is of O(n) in worst case.**